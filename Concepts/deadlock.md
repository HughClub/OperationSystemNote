## DeadLock

>   一组并发进程不能完成执行任务

正常模式下 进程使用资源顺序

1.  申请
2.  使用
3.  释放

>   `Pthread` 互斥锁多线程
>
>   -   `pthread_mutex_init` 初始化为未加锁
>   -   `pthread_mutex_lock` 获得锁
>   -   `pthread_mutex_unlock` 释放锁

引发死锁的同时成立条件

-   互斥(mutual exclusion)
-   占有并等待(hold and wait)
-   非抢占(no preemption)
-   循环等待(circular wait)

>   系统资源分配图(system resource-allocation graph) 描述死锁
>
>   从进程 $P_i$ 到资源类型 $R_j$ 的有向边记为 $P_i\to R_j$ 表示进程$P_i$申请了资源类型$R_j$的一个实例 并且正在等待资源
>
>   -   $P_i\to R_j$  申请边(request edge)
>   -   $R_j\to P_i$  分配边(assignment edge)
>
>   **分配图没有环 就没有死锁**

### 死锁处理

-   通过协议来预防或避免死锁 确保系统不会进人死锁状态
-   可以允许系统进人死锁状态 然后检测它 并加以恢复
-   忽视 认为死锁不可能在系统内发生(Linux Windows)

#### deadlock prevention

>   确保至少有一个必要条件不成立

| 死锁条件   | 不成立办法/协议                                              | 缺点                          |
| ---------- | ------------------------------------------------------------ | ----------------------------- |
| 互斥       | 必须成立                                                     |                               |
| 持有且等待 | 1. 每个进程在执行前申请并获得所有资源<br/>2. 进程仅在没有资源时才可申请资源 | 资源利用率比较低<br/>可能饥饿 |
| 非抢占     | 如果一个进程持有资源并申请另一个不能立即分配的资源 那么它现在分配的资源都可被抢占 |                               |
| 循环等待   | 对所有资源类型进行完全排序 而且要求每个进程按递增顺序来申请资源 |                               |



#### deadlock avoidance

>   操作系统事先得到有关进程申请资源和使用资源的额外信息--即如何申请资源

